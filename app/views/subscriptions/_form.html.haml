= semantic_form_for @application, :html => { class: 'form-horizontal', multipart: true } do |f|
  = f.semantic_errors

  = f.inputs do
    = f.input :confirmed, as: :hidden
    = f.input :event_id, as: :hidden
    = f.input :event_name, as: :xx_large_string, input_html: { readonly: true }, required: false
    = f.input :name, as: :xx_large_string
    = f.input :id_card
    - if @application.new_record?
      = f.input :email, as: :x_large_string
      = f.input :email_confirmation, as: :x_large_string
    = f.input :password unless @application.user
    = f.input :password_confirmation unless @application.user

    - last_section = 0
    - # To avoid N+1, sections are loaded in an array, since the field_fills are
    - # transient yet and cannot load them via ActiveRecord.
    - sections = Section.where(id: @application.field_fills.map{ |ff| ff.field.section_id }.uniq)
    = f.semantic_fields_for :field_fills do |ff|
      - section = sections.select{ |s| s.id == ff.object.field.section_id }.first
      - if section.id != last_section
        %h2= section.name
        - last_section = section.id
      = ff.input :field_id, as: :hidden, label: false
      = ff.input :type, as: :hidden, label: false
      = input_fill ff

  = f.actions do
    = f.action :submit, label: t(:subscribe), button_html: { class: 'btn btn-primary' }
